bimf=./input/chrX_5_snp#

bimf="./input/chrX_5_snp"#
#

setwd("~/Documents/AcademicResearch/kraken_files/WeiGit/gJLS2/extdata")#

nThread=2#

phenof="Pheno.txt"#

phenoNames="pheno1"#

covarNames=c("SEX", "covar1", )#

covarNames=c("SEX", "covar1", "covar2")#
#

#
bimf <- opt$bfile#
phenof <-opt$pfile#
#
phenoNames <- opt$pheno#
covarNames <- strsplit(opt$covar, ",")[[1]]#
chunk_size <- opt$write#
cat(paste("Writing in chunk size of", chunk_size, "\n"))#

require("gJLS2")#

#
if("BEDMatrix" %in% rownames(installed.packages()) == FALSE) {#
print("BEDMatrix not installed, trying to intall now ...")#
install.packages("BEDMatrix", repos='http://cran.us.r-project.org')#
}#
#
if("BGData" %in% rownames(installed.packages()) == FALSE) {#
print("BGData not installed, trying to intall now ...")#
install.packages("BGData", repos='http://cran.us.r-project.org', dependencies=T)#
}#
#
## checking inputs to be bed, fam, bim files#
#
require("BGData")#
require("BEDMatrix")#
bedFiles <- BEDMatrix(bimf)#
#
#
cat(paste("linking phenotype file", phenof, "\n"))#
#
bg <- as.BGData(bedFiles, alternatePhenotypeFile = paste0(phenof))#
	#
## CHECKING ALL INPUT FILES AGAIN:#
#
pheno_dat <- pheno(bg)#
geno_dat <- geno(bg)#
#
if (sum(grepl("SEX", names(pheno_dat)))>1){#
	names(pheno_dat)[grepl("SEX", names(pheno_dat))] <- c("SEX", paste("SEX", 1:(dim(pheno_dat[grepl("SEX", names(pheno_dat))])[2]-1), sep=""));#
}#

phenof#

phenof="./input/Pheno.txt"#
#

#
if("BEDMatrix" %in% rownames(installed.packages()) == FALSE) {#
print("BEDMatrix not installed, trying to intall now ...")#
install.packages("BEDMatrix", repos='http://cran.us.r-project.org')#
}#
#
if("BGData" %in% rownames(installed.packages()) == FALSE) {#
print("BGData not installed, trying to intall now ...")#
install.packages("BGData", repos='http://cran.us.r-project.org', dependencies=T)#
}#
#
## checking inputs to be bed, fam, bim files#
#
require("BGData")#
require("BEDMatrix")#
bedFiles <- BEDMatrix(bimf)#
#
#
cat(paste("linking phenotype file", phenof, "\n"))#
#
bg <- as.BGData(bedFiles, alternatePhenotypeFile = paste0(phenof))#
	#
## CHECKING ALL INPUT FILES AGAIN:#
#
pheno_dat <- pheno(bg)#
geno_dat <- geno(bg)#
#
if (sum(grepl("SEX", names(pheno_dat)))>1){#
	names(pheno_dat)[grepl("SEX", names(pheno_dat))] <- c("SEX", paste("SEX", 1:(dim(pheno_dat[grepl("SEX", names(pheno_dat))])[2]-1), sep=""));#
}#

SEX_cov <- as.integer(pheno_dat[,names(pheno_dat) %in% covarNames][grepl("sex|SEX|Sex", covarNames)][,1])#
	covarNames_use <- covarNames[!grepl("sex|SEX|Sex", covarNames)]#
	SEX_cov_PLINK <- ifelse(SEX_cov==0, 2, SEX_cov)#
#

SEX_cov#

SEX_cov_PLINK#

#
iter <- round(dim(geno_dat)[2]/chunk_size)#
#
final_output <- gJLS2(GENO = geno_dat[,(1):(chunk_size)], Y = pheno_dat[,names(pheno_dat) %in% phenoNames[1]], SEX = SEX_cov_PLINK, COVAR = pheno_dat[,names(pheno_dat) %in% covarNames_use], Xchr=xchr)#
#

chunk_size=5#

iter <- round(dim(geno_dat)[2]/chunk_size)#

#
final_output <- gJLS2(GENO = geno_dat[,(1):(chunk_size)], Y = pheno_dat[,names(pheno_dat) %in% phenoNames[1]], SEX = SEX_cov_PLINK, COVAR = pheno_dat[,names(pheno_dat) %in% covarNames_use], Xchr=xchr)#

dim(geno_dat[,(1):(chunk_size)])#

pheno_dat[,names(pheno_dat) %in% phenoNames[1]]#

SEX_cov_PLINK#

pheno_dat[,names(pheno_dat) %in% covarNames_use]#

xchr#

xchr=TURE#

xchr=TRUE#
#

final_output <- gJLS2(GENO = geno_dat[,(1):(chunk_size)], Y = pheno_dat[,names(pheno_dat) %in% phenoNames[1]], SEX = SEX_cov_PLINK, COVAR = pheno_dat[,names(pheno_dat) %in% covarNames_use], Xchr=xchr)#

final_output#

out#

out="./output/testRun.results.txt"#

iter#

#
if (iter > 1) {#
	#
for (j in 2:iter){#
	#
	cat(paste("Running the", j, "th chunk", "\n"))#
#
if (j == iter){#
	#
final_output <- gJLS2(GENO = geno_dat[,(1 + chunk_size*(iter-1)):dim(geno_dat)[2]], Y = pheno_dat[,names(pheno_dat) %in% phenoNames[1]], SEX = SEX_cov_PLINK, COVAR = pheno_dat[,names(pheno_dat) %in% covarNames_use], Xchr=xchr)#
#
write.table(final_output, file = out, col.names=F, row.names=F, quote=F, append=TRUE, sep="\t")#
#
} else {	#
#
final_output <- gJLS2(GENO = geno_dat[,(1 + chunk_size*(j-1)):(chunk_size*j)], Y = pheno_dat[,names(pheno_dat) %in% phenoNames[1]], SEX = SEX_cov_PLINK, COVAR = pheno_dat[,names(pheno_dat) %in% covarNames_use], Xchr=xchr)#
#
write.table(final_output, file = out, col.names=F, row.names=F, quote=F, append=TRUE, sep="\t")#
}#
}#
}#

opt$sumfile#

final_output <- gJLS2(GENO = geno_dat[,(1 + chunk_size*(iter-1)):dim(geno_dat)[2]], Y = pheno_dat[,names(pheno_dat) %in% phenoNames[1]], SEX = SEX_cov_PLINK, COVAR = pheno_dat[,names(pheno_dat) %in% covarNames_use], Xchr=xchr, nCores=nThread)#
#

devtools::install_github("WeiAkaneDeng/gJLS2")#
#

require("gJLS2")#
#

#
if("BEDMatrix" %in% rownames(installed.packages()) == FALSE) {#
print("BEDMatrix not installed, trying to intall now ...")#
install.packages("BEDMatrix", repos='http://cran.us.r-project.org')#
}#
#
if("BGData" %in% rownames(installed.packages()) == FALSE) {#
print("BGData not installed, trying to intall now ...")#
install.packages("BGData", repos='http://cran.us.r-project.org', dependencies=T)#
}#
#
## checking inputs to be bed, fam, bim files#
#
require("BGData")#
require("BEDMatrix")#
bedFiles <- BEDMatrix(bimf)#
#
cat(paste("linking phenotype file", phenof, "\n"))#
#
bg <- as.BGData(bedFiles, alternatePhenotypeFile = paste0(phenof))#
	#
## CHECKING ALL INPUT FILES AGAIN:#
#
pheno_dat <- pheno(bg)#
geno_dat <- geno(bg)#
#
if (sum(grepl("SEX", names(pheno_dat)))>1){#
	names(pheno_dat)[grepl("SEX", names(pheno_dat))] <- c("SEX", paste("SEX", 1:(dim(pheno_dat[grepl("SEX", names(pheno_dat))])[2]-1), sep=""));#
}#
#
if (!is.null(covarNames)){#
#
if (sum(grepl("sex|SEX|Sex", covarNames)) > 0){#
#
	SEX_cov <- as.integer(pheno_dat[,names(pheno_dat) %in% covarNames][grepl("sex|SEX|Sex", covarNames)][,1])#
	covarNames_use <- covarNames[!grepl("sex|SEX|Sex", covarNames)]#
	SEX_cov_PLINK <- ifelse(SEX_cov==0, 2, SEX_cov)#
#
cat(paste("Covariates include", covarNames, " from covariate/pheno file \n"))#
#
} else {#
#
	SEX_cov <- pheno_dat$SEX#
	SEX_cov_PLINK <- ifelse(SEX_cov==0, 2, SEX_cov)#
	covarNames_use <- covarNames#
#
cat(paste("Covariates did not include SEX, taking SEX from .fam file\n"))#
#
}#
#
cat(paste("Writing results to output", out, "\n"))#
#
## writing results by chunks of 50 SNPs to avoid loss in interruption#
#
#

iter <- round(dim(geno_dat)[2]/chunk_size)#
#
final_output <- gJLS2(GENO = geno_dat[,(1):(chunk_size)], Y = pheno_dat[,names(pheno_dat) %in% phenoNames[1]], SEX = SEX_cov_PLINK, COVAR = pheno_dat[,names(pheno_dat) %in% covarNames_use], Xchr=xchr, nCores=nThread)#
#
write.table(final_output, file = out, col.names=T, row.names=F, quote=F, sep="\t")#
#
if (iter > 1) {#
	#
for (j in 2:iter){#
	#
	cat(paste("Running the", j, "th chunk", "\n"))#
#
if (j == iter){#
	#
final_output <- gJLS2(GENO = geno_dat[,(1 + chunk_size*(iter-1)):dim(geno_dat)[2]], Y = pheno_dat[,names(pheno_dat) %in% phenoNames[1]], SEX = SEX_cov_PLINK, COVAR = pheno_dat[,names(pheno_dat) %in% covarNames_use], Xchr=xchr, nCores=nThread)#
#
write.table(final_output, file = out, col.names=F, row.names=F, quote=F, append=TRUE, sep="\t")#
#
} else {	#
#
final_output <- gJLS2(GENO = geno_dat[,(1 + chunk_size*(j-1)):(chunk_size*j)], Y = pheno_dat[,names(pheno_dat) %in% phenoNames[1]], SEX = SEX_cov_PLINK, COVAR = pheno_dat[,names(pheno_dat) %in% covarNames_use], Xchr=xchr, nCores= nThread)#
#
write.table(final_output, file = out, col.names=F, row.names=F, quote=F, append=TRUE, sep="\t")#
}#
}#
}#
#
} else {#
#
cat(paste("Writing results to output", out, "\n"))#
	#
iter <- round(dim(geno_dat)[2]/chunk_size)#
#
write.table(gJLS2(GENO = geno_dat[,(1):(chunk_size)], Y = pheno_dat[,names(pheno_dat) %in% phenoNames[1]], SEX = SEX_cov_PLINK,  Xchr=xchr, nCores= nThread), file = out, col.names=T, row.names=F, quote=F, sep="\t")#
#
if (iter > 1) {#
#
for (j in 2:iter){#
#
	cat(paste("Running the", j, "th chunk", "\n"))#
#
if (j == iter){#
	#
write.table(gJLS2(GENO = geno_dat[,(1 + chunk_size*(iter-1)):dim(geno_dat)[2]], Y = pheno_dat[,names(pheno_dat) %in% phenoNames[1]], SEX = SEX_cov_PLINK,  Xchr=xchr, nCores= nThread), file = out, col.names=F, row.names=F, quote=F, append=TRUE, sep="\t")#
#
	} else {	#
#
write.table(gJLS2(GENO = geno_dat[,(1 + chunk_size*(j-1)):(chunk_size*j)], Y = pheno_dat[,names(pheno_dat) %in% phenoNames[1]], SEX = SEX_cov_PLINK,  Xchr=xchr, nCores= nThread), file = out, col.names=F, row.names=F, quote=F, append=TRUE, sep="\t")#
		}	#
	}#
}#
#
#
}#
#
#

gJLS2#

library(gJLS2)#

gJLS2#
#

devtools::install_github("WeiAkaneDeng/gJLS2")#
#
#

detach(gJLS2)#

detach("gJLS2")#
#

detach("package:gJLS2")#
#
#

library(gJLS2)#
#

gJLS2#
#
#

help(package="gJLS2")#

load(".RData")#

ls#

ls()#

nThread=2#

bimf=## debug:#
bimf="./input/chrX_5_snp "#
phenof="./input/Pheno.txt"#
#

#
require("gJLS2")#
#
## checking pheno file#
#
if("BEDMatrix" %in% rownames(installed.packages()) == FALSE) {#
print("BEDMatrix not installed, trying to intall now ...")#
install.packages("BEDMatrix", repos='http://cran.us.r-project.org')#
}#
#
if("BGData" %in% rownames(installed.packages()) == FALSE) {#
print("BGData not installed, trying to intall now ...")#
install.packages("BGData", repos='http://cran.us.r-project.org', dependencies=T)#
}#
#

#
require("BGData")#
require("BEDMatrix")#
bedFiles <- BEDMatrix(bimf)#
#
cat(paste("linking phenotype file", phenof, "\n"))#
#
bg <- as.BGData(bedFiles, alternatePhenotypeFile = paste0(phenof))#
	#
## CHECKING ALL INPUT FILES AGAIN:#
#
pheno_dat <- pheno(bg)#
geno_dat <- geno(bg)#
#

bimf#

getwd()#

bimf="./input/chrX_5_snp"#
phenof="./input/Pheno.txt"#
#

#
require("BGData")#
require("BEDMatrix")#
bedFiles <- BEDMatrix(bimf)#
#
cat(paste("linking phenotype file", phenof, "\n"))#
#
bg <- as.BGData(bedFiles, alternatePhenotypeFile = paste0(phenof))#
	#
## CHECKING ALL INPUT FILES AGAIN:#
#
pheno_dat <- pheno(bg)#
geno_dat <- geno(bg)#
#

#
if (sum(grepl("SEX", names(pheno_dat)))>1){#
	names(pheno_dat)[grepl("SEX", names(pheno_dat))] <- c("SEX", paste("SEX", 1:(dim(pheno_dat[grepl("SEX", names(pheno_dat))])[2]-1), sep=""));#
}#
#
#

!is.null(covarNames)#

covarNames=c("SEX","covar1","covar2","covar3")#
#

!is.null(covarNames)#

#
if (sum(grepl("sex|SEX|Sex", covarNames)) > 0){#
#
	SEX_cov <- as.integer(pheno_dat[,names(pheno_dat) %in% covarNames][grepl("sex|SEX|Sex", covarNames)][,1])#
	covarNames_use <- covarNames[!grepl("sex|SEX|Sex", covarNames)]#
	SEX_cov_PLINK <- ifelse(SEX_cov==0, 2, SEX_cov)#
#
cat(paste("Covariates include", covarNames, " from covariate/pheno file \n"))#
#
} else {#
#
	SEX_cov <- pheno_dat$SEX#
	SEX_cov_PLINK <- ifelse(SEX_cov==0, 2, SEX_cov)#
	covarNames_use <- covarNames#
#
cat(paste("Covariates did not include SEX, taking SEX from .fam file\n"))#
#
}#
#

#
cat(paste("Writing results to output", out, "\n"))#
#
## writing results by chunks of 50 SNPs to avoid loss in interruption#
#
iter <- round(dim(geno_dat)[2]/chunk_size)#
#
final_output <- gJLS2(GENO = geno_dat[,(1):(chunk_size)], Y = pheno_dat[,names(pheno_dat) %in% phenoNames[1]], SEX = SEX_cov_PLINK, COVAR = pheno_dat[,names(pheno_dat) %in% covarNames_use], Xchr=xchr, nCores=nThread)#
#
#

chunk_size=5#

chunk_size=5-#
#

chunk_size=50#

round(dim(geno_dat)[2]/chunk_size)#
#

gJLS2(GENO = geno_dat[,(1):(chunk_size)], Y = pheno_dat[,names(pheno_dat) %in% phenoNames[1]], SEX = SEX_cov_PLINK, COVAR = pheno_dat[,names(pheno_dat) %in% covarNames_use], Xchr=xchr, nCores=nThread)#

gJLS2(GENO = geno_dat[,(1):(chunk_size)], Y = pheno_dat[,names(pheno_dat) %in% phenoNames[1]], SEX = SEX_cov_PLINK, COVAR = pheno_dat[,names(pheno_dat) %in% covarNames_use], Xchr=xchr)#
#

covarNames=c("SEX","covar1","covar2","covar3")#
phenoNames="pheno1"#
#

gJLS2(GENO = geno_dat[,(1):(chunk_size)], Y = pheno_dat[,names(pheno_dat) %in% phenoNames[1]], SEX = SEX_cov_PLINK, COVAR = pheno_dat[,names(pheno_dat) %in% covarNames_use], Xchr=xchr)#
#
#

pheno_dat[,names(pheno_dat) %in% covarNames_use]#

 xchr#

 xchr =TRUE#

gJLS2(GENO = geno_dat[,(1):(chunk_size)], Y = pheno_dat[,names(pheno_dat) %in% phenoNames[1]], SEX = SEX_cov_PLINK, COVAR = pheno_dat[,names(pheno_dat) %in% covarNames_use], Xchr=xchr)#
#
#
#

#' Scale (variance-based association) test#
#'#
#' This function takes as input the genotype of SNPs (\code{GENO}), the SEX (\code{SEX}), and a quantitative trait (\code{Y}) in a sample population, and possibly additional covariates, such as principal components. The function returns the scale association \emph{p}-values for each SNP.#
#'#
#' @param GENO a list of a genotype matrix/vector of SNPs, must contain values 0, 1, 2's coded for the number of reference allele. Alternatively, for imputed genotypes, it could either be a vector of dosage values between 0 and 2, or a list of matrix of genotype probabilities, numerically between 0 and 1 for each genotype. The length/dimension of \code{GENO} should match that of \code{Y}, and/or \code{SEX} and \code{COVAR}.#
#' @param Y a vector of quantitative traits, such as human height.#
#' @param COVAR optional: a vector or matrix of covariates that are used to reduce bias due to confounding, such as age.#
#' @param SEX optional: the genetic sex of individuals in the sample population, must be a vector of 1 and 2 following the default sex code is 1 for males and 2 for females in PLINK.#
#' @param genotypic a logical indicating whether the variance homogeneity should be tested with respect to an additively (linearly) coded or non-additively coded \code{geno_one}. The former has one less degree of freedom than the latter and is the default option. For dosage genotypes without genotypic probabilities, \code{genotypic} is forced to be \code{FALSE}.#
#' @param loc_alg a character indicating the type of algorithm to compute the centre in stage 1; the value is either "OLS", corresponding to an ordinary linear regression under Gaussian assumptions to compute the mean, or "LAD", corresponding to a quantile regression to compute the median. The recommended default option is "LAD". For the quantile regression, the function calls \code{quantreg::rq} and the median is estimated using either the "br" (smaller samples) or "sfn" (larger samples and sparse problems) algorithm depending the sample size, for more details see \code{?quantreg::rq}.#
#' @param transformed a logical indicating whether the quantitative response \code{Y} should be transformed using a rank-based method to resemble a normal distribution; recommended for traits with non-symmetric distribution. The default option is \code{FALSE}.#
#' @param Xchr a logical indicator for whether the analysis is for X-chromosome SNPs.#
#' @param origLev a logical indicator for whether the reported p-values should also include original Levene's test.#
#' @param centre a character indicating whether the absolute deviation should be calculated with respect to "median" or "mean" in the traditional sex-specific and Fisher combined Levene's test p-values (three tests) for X-chromosome. The default value is "median". This option applies to sex-specific analysis using original Levene's test (i.e. when \code{regression}$$=$$\code{TRUE}).#
#'#
#' @param related optional: a logical indicating whether the samples should be treated as related; if \code{TRUE} while no relatedness covariance information is given, it is then estimated under a \code{cov.structure} and assumes this structure among all within-group errors pertaining to the same pair/cluster if specified using \code{clust}. This option currently only applies to autosomal SNPs.#
#' @param cov.structure optional: should be one of standard classes of correlation structures listed in \code{corClasses} from \pkg{R} package \pkg{nlme}. See \code{?corClasses}. The most commonly used option is \code{corCompSymm} for a compound symmetric correlation structure. This option currently only applies to autosomal SNPs.#
#' @param clust optional: a factor indicating the grouping of samples; it should have at least two distinct values. It could be the family ID (FID) for family studies. This option currently only applies to autosomal SNPs.#
#' @param nCores optional: an integer for the number of processors/cores to split the computation. The default option is 1, without parallelizing. To check the maximum number allowed for your machine try: \code{parallel::detectCores()}.#
#'#
#' @import stats#
#' @import quantreg#
#' @import methods#
#' @import nlme#
#' @import parallel#
#'#
#'#
#' @return a vector of Levene's test regression p-values according to the models#
#' specified.#
#' @export scaleReg#
#' @note We recommend to quantile-normally transform \code{Y} to avoid ‘scale-effect’ where#
#' the variance values tend to be proportional to mean values when stratified by \code{GENO}.#
#'#
#' @examples#
#' N <- 1000#
#' genoDAT <- rbinom(N, 2, 0.3)#
#' sex <- rbinom(N, 1, 0.5)+1#
#' Y <- rnorm(N)#
#' covar <- matrix(rnorm(N*10), ncol=10)#
#'#
#' # vanilla example:#
#'#
#' scaleReg(GENO=list(genoDAT, genoDAT), Y=Y, COVAR=covar)#
#' scaleReg(GENO=list(genoDAT, genoDAT), Y=Y, COVAR=covar, genotypic=TRUE)#
#' scaleReg(GENO=list(genoDAT, genoDAT), Y=Y, COVAR=covar, origLev = TRUE)#
#' scaleReg(GENO=list(genoDAT, genoDAT), Y=Y, COVAR=covar, origLev = TRUE, SEX=sex)#
#'#
#' # parallel demonstration; NOT RUN#
#' #largerG <- matrix(rep(genoDAT,each=100), ncol=100, byrow=TRUE)#
#' #system.time(scaleReg(GENO=largerG, nCores=1, Y=Y, COVAR=covar))#
#' #system.time(scaleReg(GENO=largerG, nCores=2, Y=Y, COVAR=covar))#
#' #system.time(scaleReg(GENO=replicate(100, genoDAT, simplify=FALSE),#
#' #Y=Y, COVAR=covar, origLev = TRUE, SEX=sex, nCores=2))#
#'#
#' @author Wei Q. Deng \email{dengwq@mcmaster.ca}, Lei Sun \email{lei.sun@utoronto.ca}#
#'#
#' @references Deng WQ, Mao S, Kalnapenkis A, Esko T, Magi R, Pare G, Sun L. (2019) Analytical strategies to include the X-chromosome in variance heterogeneity analyses: Evidence for trait-specific polygenic variance structure. \emph{Genet Epidemiol}. \strong{43}(7):815-830. \doi{10.1002/gepi.22247}. PMID:31332826.#
#' @references Gastwirth JL, Gel YR, Miao W. (2009). The Impact of Levene's Test of Equality of Variances on Statistical Theory and Practice." \emph{Statistical Science}. \strong{24}(3) 343-360, \doi{10.1214/09-STS301}.#
#' @references Soave D, Sun L. (2017). A generalized Levene's scale test for variance heterogeneity in the presence of sample correlation and group uncertainty. \emph{Biometrics}. \strong{73}(3):960-971. \doi{10.1111/biom.12651}. PMID:28099998.#
#
#
#
scaleReg <- function(GENO, Y, COVAR = NULL, SEX = NULL, Xchr = FALSE, transformed=FALSE, loc_alg = "LAD", related = FALSE, cov.structure = "corCompSymm", clust = NULL, genotypic = FALSE, origLev = FALSE, centre = "median", nCores=1){#
#
  if (missing(Y))#
      stop("The quantitative trait input is missing.")#
#
  if (class(Y)!="numeric")#
      stop("Please make sure the quantitaitve trait is a numeric vector.")#
#
  if (missing(GENO))#
     stop("The genotype input is missing.")#
#
  if (!("matrix" %in% class(GENO) | "data.frame" %in% class(GENO) | "list" %in% class(GENO) | "vector" %in% class(GENO) | "integer" %in% class(GENO) | "numeric" %in% class(GENO))){#
    stop("Please make sure the genotype data is an object of vector, matrix, data.frame for discrete genotypes or a list for dosage genotypes.")#
  }#
#
  numCores <- parallel::detectCores()#
  if (nCores > numCores){#
    stop("Please make sure the nCores specified is not larger than the available cores detected.")#
  }#
#
#
  if ("vector" %in% class(GENO) | "integer" %in% class(GENO) | "numeric" %in% class(GENO)){#
#
  if (Xchr) {#
#
      p_out <- tryCatch(leveneRegX_per_SNP(geno_one=GENO, SEX = SEX, Y=Y, COVAR = COVAR, transformed=transformed, loc_alg = loc_alg, genotypic=genotypic),  error=function(e) NA)#
#
          if (origLev) {#
#
          p_out2 <- tryCatch(leveneTests_per_SNP(geno_one = GENO, SEX = SEX, Y=Y, centre = "median", transformed=TRUE),  error=function(e) NA)#
#
        if (is.null(names(GENO))){#
#
        if (is.na(p_out2)){#
          outputRes <- cbind(data.frame("CHR" = "X", "SNP" = "SNP", "gS" = p_out))#
          } else {#
          outputRes <- cbind(data.frame("CHR" = "X", "SNP" = "SNP", "gS" = p_out), p_out2)#
          }#
             } else {#
#
        if (is.na(p_out2)){#
          outputRes <-  cbind(data.frame("CHR" = "X", "SNP" = names(GENO), "gS" = p_out))#
          } else {#
        	outputRes <-  cbind(data.frame("CHR" = "X", "SNP" = names(GENO), "gS" = p_out), p_out2)#
          }#
             }#
#
             } else {#
#
        if (is.null(names(GENO))){#
#
     	outputRes <- data.frame("CHR" = "X", "SNP" = "SNP", "gS" = p_out)#
#
               } else {#
    	outputRes <- data.frame("CHR" = "X", "SNP" = names(GENO), "gS" = p_out)#
               }#
          }#
#
  } else {#
#
      p_out <- tryCatch(leveneRegA_per_SNP(geno_one = GENO, Y = Y, COVAR = COVAR, transformed=transformed, loc_alg = loc_alg, related = related, cov.structure = cov.structure, clust = clust, genotypic = genotypic),  error=function(e) NA)#
#
      if (origLev) {#
#
        p_out2 <- tryCatch(leveneTests_per_SNP(geno_one = GENO, Y=Y, centre = "median", transformed=TRUE),  error=function(e) NA)#
#
        if (is.null(colnames(GENO))|is.null(names(GENO))){#
          outputRes <- cbind(data.frame("SNP" = "SNP", "gS" = p_out), p_out2)#
#
        } else {#
          outputRes <-  cbind(data.frame("SNP" = names(GENO), "gS" = p_out), p_out2)#
        }#
#
      } else {#
#
        if (is.null(colnames(GENO))|is.null(names(GENO))){#
          outputRes <- data.frame("SNP" = "SNP", "gS" = p_out)#
#
        } else {#
#
          outputRes <- data.frame("SNP" = colnames(GENO), "gS" = p_out)#
        }#
      }#
#
      }#
#
  }#
#
#
  if ("data.frame"  %in% class(GENO) | "matrix" %in% class(GENO)){#
#
    if (Xchr) {#
#
      if (nCores > 1) {#
      output_test <- do.call(rbind, mclapply(1:dim(GENO)[2], function(ee) tryCatch(leveneRegX_per_SNP(geno_one=GENO[,ee], SEX = SEX, Y=Y, COVAR = COVAR, transformed=transformed, loc_alg = loc_alg, genotypic=genotypic), error=function(e) NULL), mc.cores=nCores))#
      } else {#
      output_test <- apply(GENO, 2, function(ee) tryCatch(leveneRegX_per_SNP(geno_one=ee, SEX = SEX, Y=Y, COVAR = COVAR, transformed=transformed, loc_alg = loc_alg, genotypic=genotypic), error=function(e) NULL))#
      }#
#
      p_out <- output_test#
      change_to_NA <- sapply(output_test, is.null)#
#
      if (length(change_to_NA)==0){#
        error_msg <- tryCatch(leveneRegX_per_SNP(geno_one=GENO[,1], SEX = SEX, Y=Y, COVAR = COVAR, transformed=transformed, loc_alg = loc_alg, genotypic=genotypic), error=function(e) e)#
        print(error_msg)#
        if(length(change_to_NA)==0) stop("Analysis terminated (Levene's XReg on a matrix of GENO). Please debug the error message.")#
#
      } else {#
#
      if (sum(change_to_NA) == length(output_test)){#
        p_out <- rep(NA, length(output_test))#
      } else {#
        NA_out <- rep(NA, length(p_out[[which(!change_to_NA)[1]]]))#
        names(NA_out) <- names(p_out[[which(!change_to_NA)[1]]])#
        p_out[which(change_to_NA)] <- list(NA_out)[rep(1, sum(change_to_NA))]#
      }#
#
      if (is.null(dim(p_out))){#
        p_out <- do.call(rbind, p_out)#
      }#
        output_test2 <- NULL#
#
      }#
#
#
      if (origLev) {#
#
        if (nCores > 1) {#
        output_test2 <- do.call(rbind, mclapply(1:dim(GENO)[2], function(ee) tryCatch(leveneTests_per_SNP(geno_one = GENO[,ee], SEX = SEX, Y=Y, centre = centre, transformed=transformed), error=function(e) NULL), mc.cores=nCores))#
        } else {#
       output_test2 <- apply(GENO, 2, function(ee) tryCatch(leveneTests_per_SNP(geno_one = ee, SEX = SEX, Y=Y, centre = centre, transformed=transformed), error=function(e) NULL))#
        }#
#
        p_out2 <- output_test2#
        change_to_NA <- sapply(output_test2, is.null)#
#
        if (length(change_to_NA)==0){#
          error_msg <- tryCatch(leveneRegX_per_SNP(geno_one=GENO[,1], SEX = SEX, Y=Y, COVAR = COVAR, transformed=transformed, loc_alg = loc_alg, genotypic=genotypic), error=function(e) e)#
          print(error_msg)#
          try(if(length(change_to_NA)==0) stop("Analysis terminated (Levene's Test for Xchr on a matrix of GENO). Please debug the error message."))#
#
        } else {#
#
        if (sum(change_to_NA) == length(output_test2)){#
          p_out2 <- NA#
        } else {#
          NA_out <- rep(NA, length(p_out2[[which(!change_to_NA)[1]]]))#
          names(NA_out) <- names(p_out2[[which(!change_to_NA)[1]]])#
          p_out2[which(change_to_NA)] <- list(NA_out)[rep(1, sum(change_to_NA))]#
        }#
#
        if (is.null(dim(p_out2)) & !is.na(p_out2)){#
          p_out2 <- do.call(rbind, p_out2)#
        }#
        }#
#
#
        if (is.null(colnames(GENO))){#
#
          if (sum(change_to_NA) == length(output_test2)) {#
          outputRes <- cbind(data.frame("CHR" = "X", "SNP" = paste("SNP_",1:dim(GENO)[2],sep=""), "gS" = p_out))#
          } else {#
          outputRes <- cbind(data.frame("CHR" = "X", "SNP" = paste("SNP_",1:dim(GENO)[2],sep=""), "gS" = p_out), p_out2)#
          }#
#
          } else {#
#
       if (sum(change_to_NA) == length(output_test2)) {#
         outputRes <- cbind(data.frame("CHR" = "X", "SNP" = colnames(GENO), "gS" = p_out))#
        } else {#
        outputRes <- cbind(data.frame("CHR" = "X", "SNP" = colnames(GENO), "gS" = p_out), p_out2)#
          }#
        }#
#
      } else {#
#
        if (is.null(colnames(GENO))){#
          outputRes <- data.frame("CHR" = "X", "SNP" = paste("SNP_",1:dim(GENO)[2],sep=""), "gS" = p_out)#
        } else {#
          outputRes <- data.frame("CHR" = "X", "SNP" = colnames(GENO), "gS" = p_out)#
        }#
      }#
#
    } else {#
#
      if (nCores > 1) {#
       output_test <- do.call(rbind, mclapply(1:dim(GENO)[2], function(ee) tryCatch(leveneRegA_per_SNP(geno_one = GENO[,ee], Y = Y, COVAR = COVAR, transformed=transformed, loc_alg = loc_alg, related = related, cov.structure = cov.structure, clust = clust, genotypic = genotypic), error=function(e) NULL), mc.cores=nCores))#
      } else {#
      output_test <- apply(GENO, 2, function(ee) tryCatch(leveneRegA_per_SNP(geno_one = ee, Y = Y, COVAR = COVAR, transformed=transformed, loc_alg = loc_alg, related = related, cov.structure = cov.structure, clust = clust, genotypic = genotypic), error=function(e) NULL))#
      }#
      p_out <- as.numeric(output_test)#
      change_to_NA <- sapply(output_test, is.null)#
#
      if (length(change_to_NA)==0){#
        error_msg <- tryCatch(leveneRegA_per_SNP(geno_one=GENO[,1], Y = Y, COVAR = COVAR, transformed=transformed, loc_alg = loc_alg, related = related, cov.structure = cov.structure, clust = clust, genotypic = genotypic), error=function(e) e)#
        print(error_msg)#
        try(if(length(change_to_NA)==0) stop("Analysis terminated (Levene's AReg on a matrix of GENO). Please debug the error message."))#
#
      } else {#
      if (sum(change_to_NA) == length(output_test)){#
        p_out <- rep(NA, length(output_test))#
      } else {#
        NA_out <- rep(NA, length(p_out[[which(!change_to_NA)[1]]]))#
        names(NA_out) <- names(p_out[[which(!change_to_NA)[1]]])#
        p_out[which(change_to_NA)] <- list(NA_out)[rep(1, sum(change_to_NA))]#
      }#
#
      if (is.null(dim(p_out))){#
        p_out <- do.call(rbind, p_out)#
      }#
      }#
#
      if (origLev) {#
#
        if (nCores > 1) {#
          output_test2 <- do.call(rbind, mclapply(1:dim(GENO)[2], function(ee) tryCatch(leveneTests_per_SNP(geno_one = GENO[,ee], SEX = SEX, Y=Y, centre = centre, transformed=transformed), error=function(e) NULL), mc.cores=nCores))#
        } else {#
          output_test2 <- apply(GENO, 2, function(ee) tryCatch(leveneTests_per_SNP(geno_one = ee, SEX = SEX, Y=Y, centre = centre, transformed=transformed), error=function(e) NULL))#
            }#
        p_out2 <- output_test2#
        change_to_NA <- sapply(output_test2, is.null)#
#
        if (length(change_to_NA)==0){#
          error_msg <- tryCatch(leveneTests_per_SNP(geno_one=GENO[,1], SEX = SEX, Y=Y, centre = centre, transformed=transformed), error=function(e) e)#
          print(error_msg)#
          try(if(length(change_to_NA)==0) stop("Analysis terminated (Levene's Test for Autosome on a matrix of GENO). Please debug the error message."))#
#
        } else {#
#
        if (sum(change_to_NA) == length(output_test2)){#
          p_out2 <- NA#
        } else {#
          NA_out <- rep(NA, length(p_out2[[which(!change_to_NA)[1]]]))#
          names(NA_out) <- names(p_out2[[which(!change_to_NA)[1]]])#
          p_out2[which(change_to_NA)] <- list(NA_out)[rep(1, sum(change_to_NA))]#
        }#
#
        if (is.null(dim(p_out2)) & !is.na(p_out2)){#
          p_out2 <- do.call(rbind, p_out2)#
        }#
        }#
#
        if (is.null(colnames(GENO))){#
#
          if (sum(change_to_NA) == length(output_test2)){#
            outputRes <- cbind(data.frame("SNP" = paste("SNP_",1:dim(GENO)[2],sep=""), "gS" = p_out))#
          } else {#
          outputRes <- cbind(data.frame("SNP" = paste("SNP_",1:dim(GENO)[2],sep=""), "gS" = p_out), p_out2)#
          }#
#
        } else {#
          if (sum(change_to_NA) == length(output_test2)){#
          outputRes <- cbind(data.frame("SNP" = colnames(GENO), "gS" = p_out))#
          } else {#
          outputRes <- cbind(data.frame("SNP" = colnames(GENO), "gS" = p_out), p_out2)#
          }#
        }#
#
      } else {#
#
        if (is.null(colnames(GENO))){#
          outputRes <- data.frame("SNP" = paste("SNP_",1:dim(GENO)[2],sep=""), "gS" = p_out)#
#
        } else {#
          outputRes <- data.frame("SNP" = colnames(GENO), "gS" = p_out)#
        }#
      }#
#
    }#
  }#
#
#
  if ("list" %in% class(GENO)){#
#
      if (Xchr) {#
#
        if (nCores > 1) {#
        output_test <- mclapply(GENO, function(ee) tryCatch(leveneRegX_per_SNP(geno_one=ee, SEX = SEX, Y=Y, COVAR = COVAR, transformed=transformed, loc_alg = loc_alg, genotypic=genotypic), error=function(e) NULL), mc.cores=nCores)#
           } else {#
        output_test <- lapply(GENO, function(ee) tryCatch(leveneRegX_per_SNP(geno_one=ee, SEX = SEX, Y=Y, COVAR = COVAR, transformed=transformed, loc_alg = loc_alg, genotypic=genotypic), error=function(e) NULL))#
        }#
#
        p_out <- output_test#
        change_to_NA <- unlist(lapply(output_test, is.null))#
#
        if (length(change_to_NA)==0){#
          error_msg <- tryCatch(leveneRegX_per_SNP(geno_one=GENO[[1]], SEX = SEX, Y=Y, COVAR = COVAR, transformed=transformed, loc_alg = loc_alg, genotypic=genotypic), error=function(e) e)#
          print(error_msg)#
          try(if(length(change_to_NA)==0) stop("Analysis terminated (Levene's XReg on a list of GENO). Please debug the error message."))#
#
        } else {#
#
        if (sum(change_to_NA) == length(output_test)){#
          p_out <- list(NA)[rep(1, length(output_test))]#
        } else {#
          NA_out <- rep(NA, length(p_out[[which(!change_to_NA)[1]]]))#
          names(NA_out) <- names(p_out[[which(!change_to_NA)[1]]])#
          p_out[which(change_to_NA)] <- list(NA_out)[rep(1, sum(change_to_NA))]#
        }#
        }#
#
      if (origLev) {#
#
      if (nCores > 1) {#
      output_test2 <- mclapply(GENO, function(ee) tryCatch(leveneTests_per_SNP(geno_one = ee, SEX = SEX, Y=Y, centre = centre, transformed=transformed), error=function(e) NULL), mc.cores=nCores)#
        } else {#
      output_test2 <- lapply(GENO, function(ee) tryCatch(leveneTests_per_SNP(geno_one = ee, SEX = SEX, Y=Y, centre = centre, transformed=transformed), error=function(e) NULL))#
         }#
#
      p_out2 <- output_test2#
      change_to_NA <- unlist(lapply(output_test2, is.null))#
#
      if (length(change_to_NA)==0){#
        error_msg <- tryCatch(leveneTests_per_SNP(geno_one=GENO[[1]],SEX = SEX, Y=Y, centre = centre, transformed=transformed), error=function(e) e)#
        print(error_msg)#
        try(if(length(change_to_NA)==0) stop("Analysis terminated (Levene's Test for Xchr on a list of GENO). Please debug the error message."))#
#
      } else {#
#
      if (sum(change_to_NA) == length(output_test2)){#
        p_out2 <- NA#
      } else {#
        NA_out <- rep(NA, length(p_out2[[which(!change_to_NA)[1]]]))#
        names(NA_out) <- names(p_out2[[which(!change_to_NA)[1]]])#
        p_out2[which(change_to_NA)] <- list(NA_out)[rep(1, sum(change_to_NA))]#
      }#
      }#
#
        if (is.null(names(GENO))){#
#
          if (sum(change_to_NA) == length(output_test2)){#
            outputRes <- cbind(data.frame("CHR" = "X", "SNP" = paste("SNP_",1:length(GENO), sep=""), "gS" = unlist(p_out)))#
          } else {#
          outputRes <- cbind(data.frame("CHR" = "X", "SNP" = paste("SNP_",1:length(GENO), sep=""), "gS" = unlist(p_out)), do.call(rbind, p_out2))#
          }#
#
        } else {#
#
       if (sum(change_to_NA) == length(output_test2)){#
          outputRes <- cbind(data.frame("CHR" = "X", "SNP" = names(GENO), "gS" = unlist(p_out)))#
          } else {#
          outputRes <- cbind(data.frame("CHR" = "X", "SNP" = names(GENO), "gS" = unlist(p_out)), do.call(rbind, p_out2))#
          }#
        }#
#
      } else {#
#
        if (is.null(names(GENO))){#
          outputRes <- data.frame("CHR" = "X", "SNP" = paste("SNP_",1:length(GENO), sep=""), "gS" = unlist(p_out))#
#
        } else {#
          outputRes <- data.frame("CHR" = "X", "SNP" = names(GENO), "gS" = unlist(p_out))#
        }#
      }#
#
    } else {#
#
      if (nCores > 1) {#
       output_test <- mclapply(GENO, function(ee) tryCatch(leveneRegA_per_SNP(geno_one = ee, Y = Y, COVAR = COVAR, transformed=transformed, loc_alg = loc_alg, related = related, cov.structure = cov.structure, clust = clust, genotypic = genotypic), error=function(e) NULL), mc.cores=nCores)#
      } else {#
      output_test <- lapply(GENO, function(ee) tryCatch(leveneRegA_per_SNP(geno_one = ee, Y = Y, COVAR = COVAR, transformed=transformed, loc_alg = loc_alg, related = related, cov.structure = cov.structure, clust = clust, genotypic = genotypic), error=function(e) NULL))#
      }#
#
      p_out <- output_test#
      change_to_NA <- unlist(lapply(output_test, is.null))#
#
      if (length(change_to_NA)==0){#
        error_msg <- tryCatch(leveneRegA_per_SNP(geno_one=GENO[[1]],  Y = Y, COVAR = COVAR, transformed=transformed, loc_alg = loc_alg, related = related, cov.structure = cov.structure, clust = clust, genotypic = genotypic), error=function(e) e)#
        print(error_msg)#
        try(if(length(change_to_NA)==0) stop("Analysis terminated (Levene's AReg on a list of GENO). Please debug the error message."))#
#
      } else {#
#
      if (sum(change_to_NA) == length(output_test)){#
        p_out <- list(NA)[rep(1, length(output_test))]#
      } else {#
        NA_out <- rep(NA, length(p_out[[which(!change_to_NA)[1]]]))#
        names(NA_out) <- names(p_out[[which(!change_to_NA)[1]]])#
        p_out[which(change_to_NA)] <- list(NA_out)[rep(1, sum(change_to_NA))]#
      }#
      }#
#
#
      if (origLev) {#
#
        if (nCores > 1) {#
        output_test2 <- mclapply(GENO, function(ee) tryCatch(leveneTests_per_SNP(geno_one = ee, SEX = SEX, Y=Y, centre = centre, transformed=transformed), error=function(e) NULL), mc.cores=nCores)#
        } else {#
        output_test2 <- lapply(GENO, function(ee) tryCatch(leveneTests_per_SNP(geno_one = ee, SEX = SEX, Y=Y, centre = centre, transformed=transformed), error=function(e) NULL))#
        }#
#
        p_out2 <- output_test2#
        change_to_NA <- unlist(lapply(output_test2, is.null))#
#
        if (length(change_to_NA)==0){#
          error_msg <- tryCatch(leveneTests_per_SNP(geno_one=GENO[[1]], SEX = SEX, Y=Y, centre = centre, transformed=transformed), error=function(e) e)#
          print(error_msg)#
          try(if(length(change_to_NA)==0) stop("Analysis terminated (Levene's Tests for Autosomes on a list of GENO). Please debug the error message."))#
#
        } else {#
#
        if (sum(change_to_NA) == length(output_test2)){#
          p_out2 <- NA#
        } else {#
          NA_out <- rep(NA, length(p_out2[[which(!change_to_NA)[1]]]))#
          names(NA_out) <- names(p_out2[[which(!change_to_NA)[1]]])#
          p_out2[which(change_to_NA)] <- list(NA_out)[rep(1, sum(change_to_NA))]#
        }#
        }#
#
        if (is.null(names(GENO))){#
#
          if (sum(change_to_NA) == length(output_test2)){#
            outputRes <- cbind(data.frame("SNP" = paste("SNP_",1:length(GENO), sep=""), "gS" = unlist(p_out)))#
          } else {#
            outputRes <- cbind(data.frame("SNP" = paste("SNP_",1:length(GENO), sep=""), "gS" = unlist(p_out)), do.call(rbind, p_out2))#
          }#
#
        } else {#
          if (sum(change_to_NA) == length(output_test2)){#
            outputRes <- cbind(data.frame("SNP" = names(GENO), "gS" = unlist(p_out)))#
          } else {#
          outputRes <- cbind(data.frame("SNP" = names(GENO), "gS" = unlist(p_out)), do.call(rbind, p_out2))#
          }#
        }#
#
      } else {#
#
        if (is.null(names(GENO))){#
          outputRes <- data.frame("SNP" = paste("SNP_",1:length(GENO), sep=""), "gS" = unlist(p_out))#
        } else {#
          outputRes <- data.frame("SNP" = names(GENO), "gS" = unlist(p_out))#
        }#
      }#
#
    }#
#
}#
#
#
  rownames(outputRes) <- NULL#
  return(outputRes)#
 }#
#
#

gJLS2(GENO = geno_dat[,(1):(chunk_size)], Y = pheno_dat[,names(pheno_dat) %in% phenoNames[1]], SEX = SEX_cov_PLINK, COVAR = pheno_dat[,names(pheno_dat) %in% covarNames_use], Xchr=xchr)#
#
#
#
#

#' A Generalized Joint-Location-Scale (gJLS) Test#
#'#
#' This function takes as input the genotype of a SNP (\code{GENO}), the SEX (\code{SEX}), and a quantitative trait (\code{Y}) in a sample population, and possibly additional covariates, such as principal components. The function returns the location and scale association \emph{p}-values for each SNP, as well as the gJLS p-value, which provides the combined evidence via Fisher's method (Soave et al., 2015, 2017). To perform this analysis genome-wide, we recommend to use the R-plugin written for PLINK, see \code{gJLSPLINK} for more details.#
#'#
#' @param GENO a list of a genotype matrix/vector of SNPs, must contain values 0, 1, 2's coded for the number of reference allele. Alternatively, for imputed genotypes, it could either be a vector of dosage values between 0 and 2, or a list of matrix of genotype probabilities, numerically between 0 and 1 for each genotype. The length/dimension of \code{GENO} should match that of \code{Y}, and/or \code{SEX} and \code{COVAR}.#
#' @param Y a vector of quantitative traits, such as human height.#
#' @param COVAR optional: a vector or matrix of covariates that are used to reduce bias due to confounding, such as age.#
#' @param SEX optional: the genetic sex of individuals in the sample population, must be a vector of 1 and 2 following the default sex code is 1 for males and 2 for females in PLINK.#
#' @param genotypic a logical indicating whether the variance homogeneity should be tested with respect to an additively (linearly) coded or non-additively coded \code{geno_one}. The former has one less degree of freedom than the latter and is the default option. For dosage genotypes without genotypic probabilities, \code{genotypic} is forced to be \code{FALSE}.#
#' @param loc_alg a character indicating the type of algorithm to compute the centre in stage 1; the value is either "OLS", corresponding to an ordinary linear regression under Gaussian assumptions to compute the mean, or "LAD", corresponding to a quantile regression to compute the median. The recommended default option is "LAD". For the quantile regression, the function calls \code{quantreg::rq} and the median is estimated using either the "br" (smaller samples) or "sfn" (larger samples and sparse problems) algorithm depending the sample size, for more details see \code{?quantreg::rq}.#
#' @param transformed a logical indicating whether the quantitative response \code{Y} should be transformed using a rank-based method to resemble a normal distribution; recommended for traits with non-symmetric distribution. The default option is \code{TRUE}.#
#' @param Xchr a logical indicator for whether the analysis is for X-chromosome SNPs.#
#' @param origLev a logical indicator for whether the reported p-values should also include original Levene's test.#
#' @param centre a character indicating whether the absolute deviation should be calculated with respect to "median" or "mean" in the traditional sex-specific and Fisher combined Levene's test p-values (three tests) for X-chromosome. The default value is "median". This option applies to sex-specific analysis using original Levene's test (i.e. when \code{regression}$$=$$\code{TRUE}).#
#' @param related optional: a logical indicating whether the samples should be treated as related; if \code{TRUE} while no relatedness covariance information is given, it is then estimated under a \code{cov.structure} and assumes this structure among all within-group errors pertaining to the same pair/cluster if specified using \code{clust}. This option currently only applies to autosomal SNPs.#
#' @param cov.structure optional: should be one of standard classes of correlation structures listed in \code{corClasses} from \pkg{R} package \pkg{nlme}. See \code{?corClasses}. The most commonly used option is \code{corCompSymm} for a compound symmetric correlation structure. This option currently only applies to autosomal SNPs.#
#' @param clust optional: a factor indicating the grouping of samples; it should have at least two distinct values. It could be the family ID (FID) for family studies. This option currently only applies to autosomal SNPs.#
#' @param XchrMethod an integer taking values 0 (reports all models), 1.1, 1.2, 2, 3, for the choice of X-chromosome location association testing models; for more details, see \code{\link{locReg}}.#
#' @param nCores optional: an integer for the number of processors/cores to split the computation. The default option is 1, without parallelizing. To check the maximum number allowed for your machine try: \code{parallel::detectCores()}.#
#'#
#'#
#' @importFrom methods is#
#' @importFrom stats resid#
#' @importFrom stats lm#
#' @importFrom stats complete.cases#
#' @importFrom stats na.exclude#
#' @importFrom stats anova#
#' @import quantreg#
#' @import nlme#
#'#
#' @return a vector of location, scale and combined gJLS p-values for each SNP.#
#' @export gJLS2#
#'#
#' @note For a genome-scan, we recommend to run this in PLINK via the plugin function \code{gJLSPLINK}, especially for large datasets and those with more than 20 covariates.#
#' @note We highly recommend to quantile-normally transform \code{Y} for non-symmetrically distributed traits. This is typically done to avoid ‘scale-effect’ when the variance values tend to be proportional to mean values when stratified by \code{GENO}, as observed by Pare et al. (2010) and Yang et al. (2011).#
#' @note For the moment, only quantitative trait \code{Y} is accepted as the subsequent generalized joint location scale (gJLS) analyses require the variance be calculated on quantitative traits. However, we are working on to include binary response for the generalized JLS analyses in the next update of gJLS.#
#'#
#' @examples#
#' N <- 1000#
#' genDAT <- rbinom(N, 2, 0.3)#
#' sex <- rbinom(N, 1, 0.5)+1#
#' y <- rnorm(N)#
#' covar <- matrix(rnorm(N*10), ncol=10)#
#'#
#' gJLS2(GENO=data.frame("SNP1" = genDAT, "aSNP1" = genDAT), SEX=sex, Y=y, COVAR=covar)#
#'#
#' gJLS2(GENO=genDAT, SEX=sex, Y=y, COVAR=covar , Xchr=TRUE)#
#'#
#'#
#' @author  Wei Q. Deng \email{dengwq@mcmaster.ca}, Lei Sun \email{lei.sun@utoronto.ca}#
#'#
#' @references Soave D, Corvol H, Panjwani N, Gong J, Li W, Boëlle PY, Durie PR, Paterson AD, Rommens JM, Strug LJ, Sun L. (2015). A Joint Location-Scale Test Improves Power to Detect Associated SNPs, Gene Sets, and Pathways. \emph{American Journal of Human Genetics}. 2015 Jul 2;\strong{97}(1):125-38. \doi{10.1016/j.ajhg.2015.05.015}. PMID: 26140448; PMCID: PMC4572492.#
#
#
#
gJLS2 <- function(GENO, Y, COVAR = NULL, SEX = NULL, Xchr = FALSE, transformed=TRUE, loc_alg = "LAD", related = FALSE, cov.structure = "corCompSymm", clust = NULL, genotypic = FALSE,  origLev = FALSE, centre = "median", XchrMethod = 3, nCores=1){#
#
  if (missing(GENO))#
    stop("The geno_onetype input is missing.")#
#
  if (missing(Y))#
    stop("The quantitative trait input is missing.")#
#
  if (class(Y)!="numeric")#
    stop("Please make sure the quantitaitve trait is a numeric vector.")#
#
  suppressWarnings(locP <- locReg(GENO=GENO, Y = Y, SEX=SEX, COVAR=COVAR, Xchr=Xchr, XchrMethod = XchrMethod, transformed = transformed, related = related, cov.structure = cov.structure, clust = clust, nCores = nCores))#
#
  suppressWarnings(scalP <- scaleReg(GENO=GENO, Y = Y, COVAR = COVAR, SEX = SEX, Xchr = Xchr, transformed=transformed, loc_alg = loc_alg, related = related, cov.structure = cov.structure, clust = clust, genotypic = genotypic,  origLev = origLev, centre = centre, nCores = nCores))#
#
  suppressMessages(merged_dat <- plyr::join(locP, scalP))#
#
  merged_dat$gJLS <- pchisq(-2*log(merged_dat$gL)-2*log(merged_dat$gS), 4, lower.tail=FALSE)#
  rownames(merged_dat) <- NULL#
#
  return(merged_dat)#
}#
#
#
#

#' Location (mean-based association) test#
#'#
#' This function takes as input the genotype of SNPs (\code{GENO}), the SEX (\code{SEX}), and a quantitative trait (\code{Y}) in a sample population, and possibly additional covariates, such as principal components. The function returns the location association \emph{p}-values for each SNP.#
#'#
#' @param GENO a list of a genotype matrix/vector of SNPs, must contain values 0, 1, 2's coded for the number of reference allele. Alternatively, for imputed genotypes, it could either be a vector of dosage values between 0 and 2, or a list of matrix of genotype probabilities, numerically between 0 and 1 for each genotype. The length/dimension of \code{GENO} should match that of \code{Y}, and/or \code{SEX} and \code{COVAR}.#
#' @param SEX the genetic sex of individuals in the sample population, must be a vector of 1's and 2's following PLINK default coding, where males are coded as 1 and females 2. \strong{Optional for analysis of autosomal SNPs, but required for X-chromosome.}#
#' @param Y a numeric vector of quantitative trait, such as human height.#
#' @param COVAR optional: a vector or a matrix of covariates, such as age or principal components.#
#' @param Xchr a logical indicator for whether the analysis is for X-chromosome SNPs, if \code{TRUE} then the following association testing model is used: Y~G+G_D+S+GxS; with p-value given by comparing Y~G+S+GxS vs. Y~S (G is the additive coded genotype; G_D is an indicator for female heterozygotes).#
#' @param related optional: a logical indicating whether the samples should be treated as related; if \code{TRUE} while no relatedness covariance information is given, it is then estimated under a \code{cov.structure} and assumes this structure among all within-group errors pertaining to the same pair/cluster if specified using \code{clust}. This option currently only applies to autosomal SNPs.#
#' @param cov.structure optional: should be one of standard classes of correlation structures listed in \code{corClasses} from \pkg{R} package \pkg{nlme}. See \code{?corClasses}. The most commonly used option is \code{corCompSymm} for a compound symmetric correlation structure. This option currently only applies to autosomal SNPs.#
#' @param clust optional: a factor indicating the grouping of samples; it should have at least two distinct values. It could be the family ID (FID) for family studies. This option currently only applies to autosomal SNPs.#
#' @param transformed a logical indicating whether the quantitative response \code{Y} should be transformed using a rank-based method to resemble a normal distribution; recommended for traits with non-symmetric distribution. The default option is \code{FALSE}.#
#' @param XchrMethod an integer taking values 0 (reports all models), 1.1, 1.2, 2, 3, for the choice of X-chromosome association testing models:#
#' model 1,1: Y~G (females only)#
#' model 1.2: Y~G (males only)#
#' model 2: Y~G+S+GxSex; with p-value given by comparing Y~G+Sex+GxSex vs. Y~Sex (the additively coded G is robust to X-chromosome inactivation uncertainty). This is also the option for dosage genotypes.#
#' model 3 (recommended): Y~G+G_D+S+GxSex; with p-value given by comparing Y ~ G+G_D+Sex+GxSex vs. Y ~ Sex (G_D is an indicator for female heterozygotes, this model is robust to X-chromosome inactivation uncertainty and skewed inactivation). For imputed data in the form of genotypic probabilities, the model becomes: Y ~ G1 + G2 + G1xSex + Sex, where G1 and G2 are the genotypic probabilities for the heterozygote and alternative allele homozygote.#
#'#
#' @param nCores optional: an integer for the number of processors/cores to split the computation. The default option is 1, without parallelizing. To check the maximum number allowed for your machine try: \code{parallel::detectCores()}.#
#'#
#' @import methods#
#' @import stats#
#' @import quantreg#
#' @import nlme#
#' @import parallel#
#'#
#' @return a vector of location association \emph{p}-values for each SNP.#
#' @export locReg#
#'#
#'#
#' @note The choice to use a rank-based inverse normal transformation is left to the user's discretion. See XXX for a discussion on the pros and cons of quantile transformation with respect to location association.#
#' @note For X-chromosome markers, when the samples consist entirely of females or males, we report only results from model 1, regardless of the \code{XchrMethod} option.#
#'#
#' @examples#
#' N <- 100#
#' genDAT <- rbinom(N, 2, 0.3)#
#' sex <- rbinom(N, 1, 0.5)+1#
#' y <- rnorm(N)#
#' COVAR <- matrix(rnorm(N*10), ncol=10)#
#'#
#' locReg(GENO=genDAT, SEX=sex, Y=y, COVAR=COVAR)#
#'#
#' # correlated example:#
#' library("MASS")#
#' yy <- mvrnorm(1, mu= rep(0, N), Sigma = matrix(0.3, N, N) + diag(0.7, N))#
#' locReg(GENO=list("SNP1"= genDAT, "SNP2" = genDAT[sample(1:100)]),#
#' SEX=sex, Y=as.numeric(yy), COVAR=COVAR, related = TRUE,#
#' clust = rep(1, 100))#
#'#
#' # sibpair example:#
#' pairedY <- mvrnorm(N/2,rep(0,2),matrix(c(1,0.2,0.2,1), 2))#
#' yy <- c(pairedY[,1], pairedY[,2])#
#' locReg(GENO=list("SNP1"= genDAT, "SNP2" = genDAT[sample(1:100)]),#
#' SEX=sex, Y=as.numeric(yy), COVAR=COVAR, related = TRUE,#
#' clust = rep(c(1:50), 2))#
#'#
#' # parallel demonstration; NOT RUN#
#' #largerG <- matrix(rep(genDAT,each=100), ncol=100, byrow=TRUE)#
#' #system.time(locReg(GENO=largerG, SEX=sex, Y=as.numeric(yy),#
#' #COVAR=COVAR, related = TRUE,clust = rep(c(1:50), 2), nCores=3))#
#' #system.time(locReg(GENO=largerG, SEX=sex, Y=as.numeric(yy),#
#' #COVAR=COVAR, related = TRUE,clust = rep(c(1:50), 2), nCores=1))#
#'#
#'#
#' # Xchr data example:#
#' genDAT1 <- rep(NA, N)#
#' genDAT1[sex==1] <- rbinom(sum(sex==1), 1, 0.5)#
#' genDAT1[sex==2] <-rbinom(sum(sex==2), 2, 0.5)#
#' locReg(GENO=genDAT1, SEX=sex, Y=y, COVAR=COVAR, Xchr=TRUE)#
#'#
#'#
#' @author Wei Q. Deng \email{dengwq@mcmaster.ca}, Lei Sun \email{lei.sun@utoronto.ca}#
#'#
#'#
#' @references Chen B, Craiu RV, Sun L. (2020) Bayesian model averaging for the X-chromosome inactivation dilemma in genetic association study. \emph{Biostatistics}. \strong{21}(2):319-335. \doi{10.1093/biostatistics/kxy049}. PMID: 30247537.#
#' @references Chen B, Craiu RV, Strug LJ, Sun L. (2021) The X factor: A robust and powerful approach to X-chromosome-inclusive whole-genome association studies. \emph{Genetic Epidemiology}. \doi{10.1002/gepi.22422}. PMID: 34224641.#
#'#
#
#
locReg <- function(GENO, Y, SEX = NULL, COVAR = NULL, Xchr=FALSE, XchrMethod = 3, transformed = FALSE, related = FALSE, cov.structure = "corCompSymm", clust = NULL, nCores=1){#
#
  if (missing(GENO))#
    stop("The genotype input is missing.")#
#
  if (!("matrix" %in% class(GENO) | "data.frame" %in% class(GENO) | "list" %in% class(GENO) | "vector" %in% class(GENO) | "integer" %in% class(GENO) | "numeric" %in% class(GENO))){#
    stop("Please make sure the genotype data is an object of vector, matrix, data.frame for discrete genotypes or a list for dosage genotypes.")#
  }#
#
  if (missing(Y))#
    stop("The quantitative trait input is missing.")#
#
  if (class(Y)!="numeric")#
    stop("Please make sure the quantitaitve trait is a numeric vector.")#
#
  numCores <- parallel::detectCores()#
  if (nCores > numCores){#
    stop("Please make sure the nCores specified is not larger than the available cores detected.")#
  }#
#
#
  if ("list" %in% class(GENO)){#
#
    ### multiple#
#
    if (nCores > 1) {#
      output_test <- mclapply(GENO, function(gg) tryCatch(locReg_per_SNP(geno_one = gg, SEX=SEX, Y=Y, COVAR = COVAR, Xchr=Xchr, XchrMethod = XchrMethod, transformed = transformed, related = related, cov.structure = cov.structure, clust = clust), error=function(e) NULL), mc.cores=nCores)#
    } else {#
      output_test <- lapply(GENO, function(gg) tryCatch(locReg_per_SNP(geno_one = gg, SEX=SEX, Y=Y, COVAR = COVAR, Xchr=Xchr, XchrMethod = XchrMethod, transformed = transformed, related = related, cov.structure = cov.structure, clust = clust), error=function(e) NULL))#
    }#
#
    output <- output_test#
    change_to_NA <- unlist(lapply(output_test, is.null))#
#
    if (length(change_to_NA)==0){#
      error_msg <- tryCatch(locReg_per_SNP(geno_one = GENO[[1]], SEX=SEX, Y=Y, COVAR = COVAR, Xchr=Xchr, XchrMethod = XchrMethod, transformed = transformed, related = related, cov.structure = cov.structure, clust = clust), error=function(e) e)#
      print(error_msg)#
      stop("Analysis terminated. Please debug the error message.")#
#
      } else {#
#
    if (sum(change_to_NA) == length(output_test)){#
      output <- list(NA)[rep(1, length(output_test))]#
    } else {#
      NA_out <- rep(NA, length(output[[which(!change_to_NA)[1]]]))#
      names(NA_out) <- names(output[[which(!change_to_NA)[1]]])#
      output[which(change_to_NA)] <- list(NA_out)[rep(1, sum(change_to_NA))]#
    }#
#
    if (is.null(names(GENO))){#
      snp_name <- paste("SNP",1:length(output), sep="_")#
    } else {#
      snp_name <- names(GENO)#
    }#
#
    if (Xchr) {#
      outputRes <- data.frame("CHR" = "X", "SNP" = snp_name, "gL" = do.call(rbind, output))#
    } else {#
      outputRes <- data.frame("SNP" = snp_name, "gL" = do.call(rbind, output))#
    }#
      rownames(outputRes) <- NULL#
      return(outputRes)#
      }#
}#
#
#
  if ("data.frame" %in% class(GENO) | "matrix" %in% class(GENO)){#
#
    if (nCores > 1) {#
      output_test <- do.call(rbind, mclapply(1:dim(GENO)[2], function(gg) tryCatch(locReg_per_SNP(geno_one = GENO[,gg], SEX=SEX, Y=Y, COVAR = COVAR, Xchr=Xchr, XchrMethod = XchrMethod, transformed = transformed, related = related, cov.structure = cov.structure, clust = clust), error=function(e) NULL), mc.cores=nCores))#
    } else {#
    output_test <- apply(GENO, 2, function(gg) tryCatch(locReg_per_SNP(geno_one = gg, SEX=SEX, Y=Y, COVAR = COVAR, Xchr=Xchr, XchrMethod = XchrMethod, transformed = transformed, related = related, cov.structure = cov.structure, clust = clust), error=function(e) NULL))#
    }#
#
    output <- output_test#
    change_to_NA <- sapply(output_test, is.null)#
#
    if (length(change_to_NA)==0){#
      error_msg <- tryCatch(locReg_per_SNP(geno_one = GENO[,1], SEX=SEX, Y=Y, COVAR = COVAR, Xchr=Xchr, XchrMethod = XchrMethod, transformed = transformed, related = related, cov.structure = cov.structure, clust = clust), error=function(e) e)#
      print(error_msg)#
      stop("Analysis terminated. Please debug the error message.")#
    } else {#
#
    if (sum(change_to_NA) == length(output_test)){#
      output <- rep(NA, length(output_test))#
    } else {#
      NA_out <- rep(NA, length(output[[which(!change_to_NA)[1]]]))#
      names(NA_out) <- names(output[[which(!change_to_NA)[1]]])#
      output[which(change_to_NA)] <- list(NA_out)[rep(1, sum(change_to_NA))]#
    }#
#
    if (is.null(dim(output))){#
      output <- do.call(rbind, output)#
    }#
#
   if (is.null(colnames(GENO))){#
      snp_name <- paste("SNP", 1:dim(output)[1], sep="_")#
    } else {#
      snp_name <- colnames(GENO)#
    }#
#
    if (Xchr) {#
      outputRes <- data.frame("CHR" = "X", "SNP" = snp_name, "gL" = output)#
    } else {#
      outputRes <- data.frame("SNP" = snp_name, "gL" = output)#
      }#
    rownames(outputRes) <- NULL#
    return(outputRes)#
    }#
  }#
#
#
  if ("vector" %in% class(GENO) | "integer" %in% class(GENO) |  "numeric" %in% class(GENO)) {#
#
    output <- tryCatch(locReg_per_SNP(geno_one = GENO, SEX=SEX, Y=Y, COVAR = COVAR, Xchr=Xchr, XchrMethod = XchrMethod, transformed =transformed, related = related, cov.structure = cov.structure , clust = clust),  error=function(e) NA)#
#
#
    if (is.null(names(GENO))){#
      snp_name <- "SNP"#
    } else {#
      snp_name <- names(GENO)#
    }#
#
    if (Xchr) {#
      outputRes <-  data.frame("CHR" = "X", "SNP" = snp_name, "gL" = output)#
    } else {#
      outputRes <-  data.frame("SNP" = snp_name, "gL" = output)#
    }#
    rownames(outputRes) <- NULL#
    return(outputRes)#
  }#
#
#
#
}#
#
#
#
###################################################################################################################################
#
#
#
locReg_per_SNP <- function(geno_one, Y, SEX = NULL, COVAR = NULL, Xchr=FALSE, XchrMethod = 3, transformed=FALSE, related = FALSE, cov.structure = "corCompSymm", clust = NULL){#
#
  ## check minimal inputes: geno_one, Y, Xchr, XchrMethods, transformed#
  if (missing(geno_one))#
    stop("The Genotype input is missing.")#
  geno_one[geno_one==-9] <- NA#
#
  ## if genotype probability matrix#
  if (!is.null(dim(geno_one))){#
    geno_check <- dim(geno_one)[2]#
#
    if (geno_check > 3 | geno_check < 2){#
      stop("Please check the genotype input, the genotype probabilitie matrix should have three columns.")#
    } else {#
      geno_one_use <- as.numeric(as.matrix(geno_one)%*%c(0,1,2))#
    }#
  }#
#
  ## if not genotype probability matrix#
  if (is.null(dim(geno_one))){#
    geno_check <- is.vector(geno_one)|is.numeric(geno_one)|is.factor(geno_one)#
   if (!geno_check){#
     stop("Please check the genotype input, it should be of class vector, numeric or factor.")#
  } else {#
    geno_range <- diff(range(as.numeric(geno_one), na.rm=T))#
    if (geno_range>2)#
      stop("Please check the genotype values, the difference between the maximum and minimum genotype value should be less than 2.")#
  }#
    geno_one_use <- geno_one#
  }#
#
  if (missing(Y))#
    stop("The quantitative trait input is missing.")#
#
  if (class(Y)!="numeric")#
    stop("Please make sure the quantitaitve trait is a numeric vector.")#
#
  ## transform before adjust for covariates#
  if (transformed){#
    Y <- inver_norm(Y)#
  }#
#
  N <- length(Y)#
#
  COVAR_use <- NULL#
  ## Replaced by either COVAR, or COVAR, SEX#
  ## for autosome use COVAR_use, for X-chromosome use COVAR#
#
  if (!is.null(COVAR)){#
#
    if (is.null(dim(COVAR))){#
#
    if (length(geno_one_use)!=length(COVAR)|length(geno_one_use)!=length(Y)|length(Y)!=length(COVAR))#
      stop("Make sure the inputs have the same length.")#
#
    } else {#
#
      if (length(geno_one_use)!=dim(COVAR)[1]|length(geno_one_use)!=length(Y)|length(Y)!=dim(COVAR)[1])#
        stop("Make sure the inputs have the same length.")#
    }#
#
    ### if not for Xchr, we can treat SEX as part of covariate#
    if (!is.null(SEX) & !Xchr){#
#
      if (sum(SEX %in% c(1,2,NA))!=length(SEX))#
        stop("Please check the SEX variable, only 1, 2, and NA are plausible values.")#
#
      SEX[SEX==2] = 0#
#
      if (length(geno_one_use)!=length(SEX)|length(geno_one_use)!=length(Y)|length(Y)!=length(SEX))#
        stop("Make sure the inputs: SEX, Y, and geno_one have the same length.")#
#
      if (sum(SEX==1, na.rm= TRUE) == sum(!is.na(SEX))){#
        warning("Only Males detected")#
#
      } else if (sum(SEX==0, na.rm= TRUE) == sum(!is.na(SEX))) {#
#
        warning("Only Females detected")#
      }#
#
      COVAR_use <- cbind(COVAR, SEX)#
    }#
    }#
#
  ### if not for Xchr and no covariate, we can treat SEX as covariate#
  if (is.null(COVAR) & !is.null(SEX) & !Xchr){#
#
    if (sum(SEX %in% c(1,2,NA))!=length(SEX))#
      stop("Please check the SEX variable, only 1, 2, and NA are plausible values.")#
#
    SEX[SEX==2] = 0#
#
    if (length(geno_one_use)!=length(SEX)|length(geno_one_use)!=length(Y)|length(Y)!=length(SEX))#
      stop("Make sure the inputs: SEX, Y, and geno_one have the same length.")#
#
      if (sum(SEX==1, na.rm= TRUE) == sum(!is.na(SEX))){#
      warning("Only Males detected")#
#
      } else if (sum(SEX==0, na.rm= TRUE) == sum(!is.na(SEX))) {#
#
      warning("Only Females detected")#
    } else {#
#
      COVAR_use <- SEX#
    }#
    }#
#
### begin analysis of autosomes:#
#
if (!Xchr) {#
#
     if (length(table(geno_one_use))==1) {#
        warning("Monomorphic SNP detected, results will be set to N/A");#
        pval <- NA#
        names(pval) <- "p-value"#
#
        } else {#
#
        ## autosomal related / not related models:#
          if (!related){#
            ## if not related then analyze as usual#
#
            if (is.null(COVAR_use)){#
              ### no covariates:#
              use_dat <- complete.cases(geno_one_use, Y)#
              datafr <- data.frame("y" = Y[use_dat], "g" = geno_one_use[use_dat])#
              pval <- summary(lm(y ~ g, data=datafr))$coef[2,4]#
#
             } else {#
               ### covariates:#
               use_dat <- complete.cases(geno_one_use, Y, COVAR_use)#
               if (is.null(dim(COVAR_use))){#
                 datafr <- data.frame("y" = Y[use_dat], "g" = geno_one_use[use_dat], "covar" = COVAR_use[use_dat])#
               } else {#
                 datafr <- data.frame("y" = Y[use_dat], "g" = geno_one_use[use_dat], "covar" = COVAR_use[use_dat,])#
               }#
               pval <- summary(lm(as.formula(paste("y ~ g +", paste(names(datafr)[grepl("covar",names(datafr))], collapse = "+"))), data=datafr))$coef[2,4]#
             }#
#
          } else {#
#
            if (is.null(clust)) {#
              clust = rep(1, N)#
              warning("No cluster assignment was given, treating the samples as a single group.")#
            }#
            clust <- as.factor(clust)#
#
            if (missing(cov.structure))#
              stop("The cov.structure input is missing, should be one of the standard classes of correlation structures in corClasses. See ?nlme::corClasses for more details. The default option is corCompSymm.")#
#
            if (is.null(COVAR_use)){#
                use_dat <- complete.cases(geno_one_use, clust, Y)#
                datafr <- data.frame("y" = Y[use_dat], "g" = geno_one_use[use_dat], "clust" = clust[use_dat])#
                correlation_est = output_correlation(y = datafr$y, clust = datafr$clust, cov.structure = cov.structure)#
                fit <- nlme::gls(y~g, data=datafr, correlation=correlation_est, method="ML",control=lmeControl(opt = "optim"))#
                pval <- anova(fit,Terms=2)[1,3]#
             } else {#
#
               use_dat <- complete.cases(geno_one_use, Y, COVAR_use, clust)#
               if (is.null(dim(COVAR_use))){#
                 datafr <- data.frame("y" = Y[use_dat], "g" = geno_one_use[use_dat], "covar" = COVAR_use[use_dat], "clust" = clust[use_dat])#
               } else {#
                 datafr <- data.frame("y" = Y[use_dat], "g" = geno_one_use[use_dat], "covar" = COVAR_use[use_dat,], "clust" = clust[use_dat])#
               }#
               correlation_est = output_correlation(y = datafr$y, clust = datafr$clust, cov.structure = cov.structure)#
               fit <- nlme::gls(as.formula(paste("y ~ g +", paste(names(datafr)[grepl("covar",names(datafr))], collapse = "+"))), data=datafr, correlation=correlation_est, method="ML",control=lmeControl(opt = "optim"))#
               pval <- anova(fit,Terms=2)[1,3]#
             }#
          }#
#
## end of autosomal analysis#
        }#
#
## Xchr not related models:#
} else {#
#
if (length(table(geno_one_use))==1) {#
#
    warning("Monomorphic SNP detected, results will be set to N/A");#
    pval <- NA#
    names(pval) <- "p-value"#
#
  } else {#
#
  ### need to check if there is heterozygotes in discrete genotype for Xchr#
  if (length(unique(geno_one_use)) <= 4 & sum(geno_one_use == 1, na.rm=T) > 1){#
    imputed = FALSE#
  } else {#
    imputed = TRUE#
  }#
#
  if (is.null(SEX))#
    stop("The sex input is missing for X-chromosome analysis.")#
#
  if (sum(SEX %in% c(1,2,NA))!=length(SEX))#
    stop("Please check the SEX variable, only 1, 2, and NA are plausible values.")#
#
  SEX[SEX==2] = 0#
#
    if (is.null(COVAR)){#
    ## no covariates:#
#
        use_dat <- complete.cases(geno_one_use, SEX, Y)#
        datafr <- data.frame("y" = Y[use_dat], "g" = geno_one_use[use_dat], "sex" =  SEX[use_dat])#
#
        ### no covariates:#
        if (sum(SEX==1, na.rm=TRUE) == sum(!is.na(SEX))){#
          warning("Only Males detected")#
          p2 <- summary(lm(y~g, data=datafr[datafr$sex==1,]))$coef[2,4]#
          pval <- p2#
          names(pval) <- "model 1 (males)"#
#
        } else if (sum(SEX==0, na.rm=TRUE) == sum(!is.na(SEX))) {#
          warning("Only Females detected")#
          p1 <- summary(lm(y~g, data=datafr[datafr$sex==0,]))$coef[2,4]#
          pval <-p1#
          names(pval) <- "model 1 (females)"#
#
        } else {#
#
          if (!imputed){#
            ## heterzygote in females only#
              datafr$gD <- ifelse(datafr$g==1 & datafr$sex == 0, 1, 0)#
              p1 <- summary(lm(y~g, data=datafr[datafr$sex==0,]))$coef[2,4]#
              p2 <- summary(lm(y~g, data=datafr[datafr$sex==1,]))$coef[2,4]#
              m1 <- lm(y~sex+g+gD+g:sex, data=datafr)#
              m11 <- lm(y~sex+g+g:sex, data=datafr)#
              m2 <- lm(y~sex, data=datafr)#
              p_val_01 <- anova(m11, m2)[2,6]#
              p_val_02 <- anova(m1, m2)[2,6]#
#
              pval_Xchr <-c(p1, p2, p_val_01, p_val_02)#
              names(pval_Xchr) <- c("model 1 (females)", "model 1 (males)", "model 2", "gL")#
#
              if (XchrMethod == 0) {#
                pval <- pval_Xchr#
              } else if (XchrMethod == 1) {#
                pval <- pval_Xchr[1:2]#
              } else if (XchrMethod == 2) {#
                pval <- pval_Xchr[3]#
              } else if (XchrMethod == 3) {#
                pval <- pval_Xchr[4]#
              }#
#
              } else {#
#
              ## imputed: but in dosage values (models 1,2 only)#
              if (is.null(dim(geno_one))){#
#
                p1 <- summary(lm(y~g, data=datafr[datafr$sex==0,]))$coef[2,4]#
                p2 <- summary(lm(y~g, data=datafr[datafr$sex==1,]))$coef[2,4]#
                m11 <- lm(y~sex+g+g:sex, data=datafr)#
                m2 <- lm(y~sex, data=datafr)#
                p_val_01 <- anova(m11, m2)[2,6]#
#
                pval_Xchr <-c(p1, p2, p_val_01)#
                names(pval_Xchr) <- c("model 1 (females)", "model 1 (males)", "gL")#
#
                if (XchrMethod == 0) {#
                  pval <- pval_Xchr#
                } else if (XchrMethod == 1) {#
                  pval <- pval_Xchr[1:2]#
                } else if (XchrMethod == 2) {#
                  pval <- pval_Xchr[3]#
                }#
#
                if (XchrMethod == 3 & imputed){#
                  warning("For X-chromosome analysis, dosage genotypes will be analyzed using either method 1 (females only) or method 2 (no non-additive component)")#
                  warning("Returning results for method 1 and 2...")#
                  pval <- pval_Xchr#
                }#
#
              } else {#
#
                use_dat <- complete.cases(geno_one_use, SEX, Y, geno_one)#
                datafr <- data.frame("y" = Y[use_dat], "g" = geno_one_use[use_dat], "g1" = geno_one[use_dat, 2], "g2" = geno_one[use_dat, 3], "sex" =  SEX[use_dat])#
#
                p1 <- summary(lm(y~g, data=datafr[datafr$sex==0,]))$coef[2,4]#
                p2 <- summary(lm(y~g, data=datafr[datafr$sex==1,]))$coef[2,4]#
                m11 <- lm(y~sex+g+g:sex, data=datafr)#
                m2 <- lm(y~sex, data=datafr)#
                m1 <- lm(y~sex+g1+g2+g1:sex, data=datafr)#
                p_val_02 <- anova(m1, m2)[2,6]#
                p_val_01 <- anova(m11, m2)[2,6]#
#
                pval_Xchr <-c(p1, p2, p_val_01)#
                names(pval_Xchr) <- c("model 1 (females)", "model 1 (males)", "model 2", "gL")#
#
                if (XchrMethod == 0) {#
                  pval <- pval_Xchr#
                } else if (XchrMethod == 1) {#
                  pval <- pval_Xchr[1:2]#
                } else if (XchrMethod == 2) {#
                  pval <- pval_Xchr[3]#
                } else if (XchrMethod == 3) {#
                  pval <- pval_Xchr[4]#
                }#
#
              }#
#
            }#
        }#
#
    } else {#
    ## yes covariates:#
      use_dat <- complete.cases(geno_one_use, SEX, Y, COVAR)#
        if (is.null(dim(COVAR))){#
          datafr <- data.frame("y" = Y[use_dat], "g" = geno_one_use[use_dat], "covar" = COVAR[use_dat], "sex" = SEX[use_dat])#
          } else {#
        datafr <- data.frame("y" = Y[use_dat], "g" = geno_one_use[use_dat], "covar" = COVAR[use_dat,], "sex" = SEX[use_dat])#
          }#
#
        if (sum(SEX==1,na.rm=TRUE) == sum(!is.na(SEX))){#
          warning("Only Males detected")#
          p2 <- summary(lm(as.formula(paste("y ~ g +", paste(names(datafr)[grepl("covar",names(datafr))], collapse = "+"))), data=datafr))$coef[2,4]#
          pval <- p2#
          names(pval) <- "model 1 (males)"#
#
        } else if (sum(SEX==0,na.rm=TRUE) == sum(!is.na(SEX))) {#
          warning("Only Females detected")#
          p1 <- summary(lm(as.formula(paste("y ~ g +", paste(names(datafr)[grepl("covar",names(datafr))], collapse = "+"))), data=datafr))$coef[2,4]#
          pval <-p1#
          names(pval) <- "model 1 (females)"#
#
        } else {#
#
          if (!imputed){#
#
           ## heterzygote in females only#
          datafr$gD <- ifelse(datafr$g==1 & datafr$sex == 0, 1, 0)#
#
            p1 <- summary(lm(as.formula(paste("y ~ g +", paste(names(datafr[datafr$sex==0,])[grepl("covar",names(datafr[datafr$sex==0,]))], collapse = "+"))), data=datafr[datafr$sex==0,]))$coef[2,4]#
            p2 <- summary(lm(as.formula(paste("y ~ g +", paste(names(datafr[datafr$sex==1,])[grepl("covar",names(datafr[datafr$sex==1,]))], collapse = "+"))), data=datafr[datafr$sex==1,]))$coef[2,4]#
            m1 <- lm(as.formula(paste("y ~ sex+g+gD+g:sex + ", paste(names(datafr)[grepl("covar",names(datafr))], collapse = "+"))), data=datafr)#
            m11 <- lm(as.formula(paste("y ~ sex+g+g:sex + ", paste(names(datafr)[grepl("covar",names(datafr))], collapse = "+"))), data=datafr)#
            m2 <- lm(as.formula(paste("y ~ sex + ", paste(names(datafr)[grepl("covar",names(datafr))], collapse = "+"))), data=datafr)#
            p_val_01 <- anova(m11, m2)[2,6]#
            p_val_02 <- anova(m1, m2)[2,6]#
#
            pval_Xchr <-c(p1, p2, p_val_01, p_val_02)#
            names(pval_Xchr) <- c("model 1 (females)", "model 1 (males)", "model 2", "gL")#
#
            if (XchrMethod == 0) {#
              pval <- pval_Xchr#
            } else if (XchrMethod == 1) {#
              pval <- pval_Xchr[1:2]#
            } else if (XchrMethod == 2) {#
              pval <- pval_Xchr[3]#
            } else if (XchrMethod == 3) {#
              pval <- pval_Xchr[4]#
            }#
#
          } else {#
#
            ## imputed: but in dosage values (models 1,2 only)#
            if (is.null(dim(geno_one))){#
#
              p1 <- summary(lm(as.formula(paste("y ~ g +", paste(names(datafr[datafr$sex==0,])[grepl("covar",names(datafr[datafr$sex==0,]))], collapse = "+"))), data=datafr[datafr$sex==0,]))$coef[2,4]#
              p2 <- summary(lm(as.formula(paste("y ~ g +", paste(names(datafr[datafr$sex==1,])[grepl("covar",names(datafr[datafr$sex==1,]))], collapse = "+"))), data=datafr[datafr$sex==1,]))$coef[2,4]#
              m11 <- lm(as.formula(paste("y ~ sex+g+g:sex + ", paste(names(datafr)[grepl("covar",names(datafr))], collapse = "+"))), data=datafr)#
              m2 <- lm(as.formula(paste("y ~ sex + ", paste(names(datafr)[grepl("covar",names(datafr))], collapse = "+"))), data=datafr)#
              p_val_01 <- anova(m11, m2)[2,6]#
#
              pval_Xchr <-c(p1, p2, p_val_01)#
              names(pval_Xchr) <- c("model 1 (females)", "model 1 (males)", "gL")#
#
              if (XchrMethod == 0) {#
                pval <- pval_Xchr#
              } else if (XchrMethod == 1) {#
                pval <- pval_Xchr[1:2]#
              } else if (XchrMethod == 2) {#
                pval <- pval_Xchr[3]#
              }#
#
              if (XchrMethod == 3 & imputed){#
                warning("For X-chromosome analysis, dosage genotypes will be analyzed using either method 1 (females only) or method 2 (no non-additive component)")#
                warning("Returning results for method 1 and 2...")#
                pval <- pval_Xchr#
              }#
#
            } else {#
#
              use_dat <- complete.cases(geno_one_use, SEX, Y, geno_one, COVAR)#
              datafr <- data.frame("y" = Y[use_dat], "g" = geno_one_use[use_dat], "g1" = geno_one[use_dat, 2], "g2" = geno_one[use_dat, 3], "sex" =  SEX[use_dat], "covar" = COVAR[use_dat])#
#
              p1 <- summary(lm(as.formula(paste("y ~ g +", paste(names(datafr[datafr$sex==0,])[grepl("covar",names(datafr[datafr$sex==0,]))], collapse = "+"))), data=datafr[datafr$sex==0,]))$coef[2,4]#
              p2 <- summary(lm(as.formula(paste("y ~ g +", paste(names(datafr[datafr$sex==1,])[grepl("covar",names(datafr[datafr$sex==1,]))], collapse = "+"))), data=datafr[datafr$sex==1,]))$coef[2,4]#
              m11 <- lm(as.formula(paste("y ~ sex+g+g:sex + ", paste(names(datafr)[grepl("covar",names(datafr))], collapse = "+"))), data=datafr)#
              m2 <- lm(as.formula(paste("y ~ sex + ", paste(names(datafr)[grepl("covar",names(datafr))], collapse = "+"))), data=datafr)#
              m1 <- lm(as.formula(paste("y ~ sex+g1+g2+g1:sex + ", paste(names(datafr)[grepl("covar",names(datafr))], collapse = "+"))), data=datafr)#
              p_val_02 <- anova(m1, m2)[2,6]#
              p_val_01 <- anova(m11, m2)[2,6]#
#
              pval_Xchr <-c(p1, p2, p_val_01, p_val_02)#
              names(pval_Xchr) <- c("model 1 (females)", "model 1 (males)", "model 2", "gL")#
#
              if (XchrMethod == 0) {#
                pval <- pval_Xchr#
              } else if (XchrMethod == 1) {#
                pval <- pval_Xchr[1:2]#
              } else if (XchrMethod == 2) {#
                pval <- pval_Xchr[3]#
              } else if (XchrMethod == 3) {#
                pval <- pval_Xchr[4]#
              }#
#
            }#
#
#
#
          }#
        }#
}#
#
}#
#
}#
## end of analysis#
  return(pval)#
}#
#
#

gJLS2(GENO = geno_dat[,(1):(chunk_size)], Y = pheno_dat[,names(pheno_dat) %in% phenoNames[1]], SEX = SEX_cov_PLINK, COVAR = pheno_dat[,names(pheno_dat) %in% covarNames_use], Xchr=xchr)#
#
#
#
#
#

chunk_size#

final_output <- gJLS2(GENO = geno_dat[,(1):max(dim(geno_dat)[2], chunk_size)], Y = pheno_dat[,names(pheno_dat) %in% phenoNames[1]], SEX = SEX_cov_PLINK, COVAR = pheno_dat[,names(pheno_dat) %in% covarNames_use], Xchr=xchr, nCores=nThread)#
#

dim(geno_dat[,(1):max(dim(geno_dat)[2], chunk_size)])#

max(dim(geno_dat)[2], chunk_size)#

final_output <- gJLS2(GENO = geno_dat[,(1):min(dim(geno_dat)[2], chunk_size)], Y = pheno_dat[,names(pheno_dat) %in% phenoNames[1]], SEX = SEX_cov_PLINK, COVAR = pheno_dat[,names(pheno_dat) %in% covarNames_use], Xchr=xchr, nCores=nThread)#
#

